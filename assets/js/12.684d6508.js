(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{402:function(t,n,e){"use strict";e.r(n);var s=e(2),a=Object(s.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v("虚拟DOM和diff算法\n新虚拟DOM和老虚拟DOM进行diff（精细化比较），算出应该如何最小量更新，最后反映到真正的DOM上。虚拟DOM：用JavaScript对象描述DOM的层次结构。DOM  中的一切属性都在虚拟DOM中有对应的属性。\n封装了5个函数：\n"),t("strong",[this._v("h函数")]),this._v("用来产生虚拟节点，调用h函数将返回一个对象，对象中有children data elm key sel text 属性\npatch函数用来使虚拟节点上树，\npatchVnode函数用来比较更新旧节点与新节点\nvnode函数用在h函数中，用来返回一个虚拟节点对象\ncreateElm函数用来创建一个孤儿DOM节点")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[this._v("首先patch函数被调用，判断oldVnode是虚拟节点还是真实节点，如果是真实节点，将之变为虚拟节点，如果本来就是虚拟节点，则与newVnode进行比较，如果两个对象的sel与key相同，则调用pathVnode函数进行最小量更新，如果不同，就删除旧节点，插入新节点。进行最小量更新时，首先判断旧节点与新节点是不是同一个对象，如果是，则什么也不做，如果不是同一个对象，就判断新节点是否有text属性，如果有，就覆盖旧节点的elm的innerText改为新节点的text属性值，如果新节点没有text属性，说明二者均有children属性，二者都有子节点，然后就进行旧节点与新节点的子节点diff更新，四种更新策略，分别是新前与旧前、新后与旧后、新后和旧前、新前和旧后，意为尚未处理的新子节点中的第一个节点。命中时，均需要先进行patchVnode，如果命中新后和旧前，则将patchvnode后的新后节点移动到旧后之后，如果命中新前和旧后，则将patchVnode后的新前移动到旧前之前。\n")])])]),t("p",[this._v("key是这个节点的唯一标识，告诉diff算法，在更改前后它们是同一个DOM节点。\n• 只有是同一个虚拟节点，才进行精细化比较，否则就是暴力删除旧的、插入新的。\n延伸问题：如何定义是同一个虚拟节点？答：选择器sel相同且key相同。\n• 只进行同层比较，不会进行跨层比较。即使是同一片虚拟节点，但是跨层了，对\n不起，精细化比较不diff你，而是暴力删除旧的、然后插入新的。\n"),t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/26732147/1647782316802-8064a185-638c-48d3-a7cf-7f3e623528b6.png#",alt:""}})])])}),[],!1,null,null,null);n.default=a.exports}}]);